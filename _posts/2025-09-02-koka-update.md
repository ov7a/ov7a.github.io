---
layout: post
title: Еще немного Koka
tags: [koka, blogdev, github, algorithms]
category: blog
tg_id: 647
---
Финальная (надеюсь) часть истории про Koka.
Предыдущие части: [первая](/2025/04/05/koka.html), [вторая](/2025/07/23/koka-search.html).

По сути, доделал, что хотел доделать, и поэкспериментировал с чем хотел.

## Получил обратную связь

[Запостил](https://github.com/orgs/koka-community/discussions/9) ссылку на свой проектик, получил небольшой фидбек от одного из разработчиков.
Мелочь, но приятно.
Многого и не ждал, т.к. номер обсуждения — девять, и это первое обсуждение в категории "покажи свой проект".

Когда переходил по ссылкам, внезапно узнал, что ссылки на обсуждения на GitHub имеют сквозную нумерацию с тикетами и PR в репозитории организации.
Например, [эта ссылка](https://github.com/orgs/koka-community/discussions/1) на первое обсуждение перенаправляет на [первый PR](https://github.com/koka-community/koka-community/pull/1).

## Улучшил сборку

Отрефакторил пайплайн сборки — в итоге сам поиск собирается [в релиз](/2025/08/05/github-actions-release.html) при публикации нового тега, и уже он используется при сборке сайта.
Все [обмазано кэшами](/2025/07/31/github-actions-cache.html).
Попутно оптимизировал сборку, чтобы было не 60 мегов, а 31.
По умолчанию [все печально](https://github.com/koka-lang/koka/issues/277).

Посмотрел на [action](https://github.com/koka-community/setup-koka/blob/v1/action.yml) от разработчика и на разрабатываемый [пакетный менеджер](https://github.com/koka-community/kokaw/blob/main/kokaw/package.kk) — ну, такое, мягко говоря...
Остался на своих велосипедах.

Обновил версию языка и библиотеки.
Увы, особо много интересного не было, за исключением возможности использовать `_` в лямбдах как в Scala.

## Внес вклад в сообщество

Я открыл еще 8 (восемь!) [тикетов](https://github.com/search?q=org%3Akoka-lang+org%3Akoka-community+author%3Aov7a&type=issues&s=created&o=desc), 5 [пулл-реквестов](https://github.com/search?q=org%3Akoka-lang+org%3Akoka-community+author%3Aov7a&type=pullrequests&s=created&o=desc) и одно обсуждение с [тупейшим вопросом](https://github.com/koka-lang/koka/discussions/799).
Как будто уже на них работаю, кек:)
В библиотеки сообщества все быстро приняли, а в основном репозитории пока почти нет реакции.

## Навалил фич

В первую очередь сделал префиксый поиск для последнего токена — наконец-то пригодилось ДДП!
Правда, пришлось писать самопальный [поиск элементов, следующих за данным](https://github.com/ov7a/klava/blob/30c51055239e47c1c50302513f8cf53f5e54a634/src/utils/map.kk#L53).
В стандартной библиотеке толком не используется факт упорядоченности `map` и никаких методов нет.

Вообще, уже одна эта фича улучшила поиск существенно.
Несмотря на искусственное понижение результатов в выдаче, именно с префиксного поиска больше всего полезных результатов выпадает.

Пока вспоминал базу с ДДП, написал первые тесты.
Не обошлось [без проблем](https://github.com/koka-community/std/issues/43), но поправил сам, и получилось терпимо.

Наконец, написал [стеммер](https://github.com/ov7a/klava/blob/main/src/core/stem.kk).
Смысла в нем не очень много, но изначально хотел его сделать и решил все-таки поставить галочку.
Сам [алгоритм](http://snowball.tartarus.org/algorithms/russian/stemmer.html) оказался гораздо проще, чем я думал, практически вызов цепочкой однообразных функций с разными параметрами.
До самих функций конечно надо додуматься, но на это не ушло много времени.

Уже на стадии чтения описания алгоритма я почти сразу придумал слово, которое будет плохо обработано: "карась" будет урезан до "кар" из-за возвратного "сь".
Поэкспериментировать самостоятельно можно [тут](https://snowballstem.org/demo.html#Russian), таких примеров можно найти много.
Но многого ожидать от бесконтекстных стеммеров не стоит, да мне и не надо.

У стемминга есть нюанс, что он потенциально не очень хорошо сочетается с префиксным поиском для поиска длинных строк, но я не заметил разницы на реальных данных.
Но у него есть и безусловный плюс — уменьшение размера индекса почти в 1,5 раза (JSON с индексом теперь 1,1 Мб вместо 1,6 Мб).
Ну и точность ранжирования должна быть получше за счет объединения терминов.

Больше времени убил на борьбу со стандартной библиотекой.
Не смотря на то, что там есть проекция (view) строки, нужных мне методов там не оказалось, и доступа к отдельным символам по индексу тоже.
Я сначала честно пытался что-то построить с существующим API, но в итоге признал поражение и написал [свою](https://github.com/ov7a/klava/blob/main/src/utils/string-view.kk) урезанную проекцию из велосипедов и грязных `while` с нужными мне методами.

Но на этом приколы со стандартной библиотекой не закончились.
Внезапно обнаружилось, что в ней нет `flatmap` для `maybe`.
Позже — совсем мрак: нет `contains` для списка!
Ладно, есть `any`, но это как вместо `isEmpty` писать `.count > 0` (передаю [привет](https://stackoverflow.com/questions/18867180/check-if-list-is-empty-in-c-sharp) C#).

Наконец, последней фичей стало переключение раскладки — "ns gbljh" чтобы искалось.
Реализуется тоже элементарно, главное учесть, что смену раскладки надо сделать до токенизации (иначе всякие бюжъх потеряются), но после приведения к нижнему регистру.

## Заключение

В целом, не ожидал, что после первой провальной попытки будет столько мотивации работать над этим проектом.
Результатом я весьма доволен, получилось то, что я хотел.
И что-то новое по дороге узнал, и со старых навыков сдул пыль.
Надеюсь, что после пары минорных правок успокоюсь и переключусь на что-то другое:)

