---
layout: post
title: Таймеры на сервисных тасках в Camunda
tags: [camunda]
---
В Camunda таймеры не работают на сервисных тасках. Т.е. такой таймер

![](https://docs.camunda.org/manual/7.15/user-guide/process-engine/img/NotWorkingTimerOnServiceTimeout.png)

[никогда не сработает](https://docs.camunda.org/manual/7.15/user-guide/process-engine/transactions-in-processes/#reasoning-for-this-design). Связано это с реализованным механизмом транзакций. Таймер создается при заходе токена на таску, поэтому он просто не существует вне транзакции. Получается, таймеры не могут сработать, пока транзакция не закроется, а транзакция не закрывается, пока не завершится сервисный таск.

Что делать?

Если таск внешний, то таймер [будет работать](https://forum.camunda.org/t/timer-boundary-event-on-service-tasks/2158/7), потому что внешние таски находятся в состоянии ожидания (транзакция закрывается). Однако это будет означать разделение камунды и бизнес-логики на два сервиса и переход на Rest API вместо внутреннего.

Еще один вариант — реализовать [паттерн асинхронного выполнения задач](https://github.com/camunda/camunda-bpm-examples/tree/master/servicetask/service-invocation-asynchronous), в котором само задание кладется во внутреннюю очередь, потом транзакция закрывается и таск ждет сигнала-коллбека от обработчика задач. Но цена этому — отсутствие отката при ошибке.

Третий вариант — таймауты можно обрабатывать внутри логики делегата и кидать ошибку/эскалацию самостоятельно.

Наконец, можно отрефакторить схему так, чтобы таймер не был на сервисной таске. Однако банально выделить его в параллельную ветку с каким-нибудь условием не получится: параллельные ветки на схеме в движке выполняются на самом деле [последовательно](https://docs.camunda.org/manual/7.15/user-guide/process-engine/transactions-in-processes/#reasoning-for-this-design).

