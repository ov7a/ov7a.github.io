---
layout: post
title: Scala JS
tags: [scala, javascript]
---
Портировать существующий проект с обработкой заявок на Scala JS оказалось довольно легко (ну, с учетом того, что там нет зависимостей): [берем туториал](https://www.scala-js.org/doc/tutorial/basic/), выполняем немного пунктов из него, меняем немного IO — заменяем чтение из файла на чтение из textarea, аналогично меняем main, добавляем простенькую html-ку и готово. Единственное, обо что споткнулся на первой итерации — нужно было сделать явное преобразование `asInstanceOf[TextArea]` после `document.getElementById`, но это логично и мелочевка.

На простых примерах работало отлично, на основном примере — подвисло аж на 45 секунд. Браузер трижды предлагал убить скрипт. Размер сборки, кстати — 1.2Мб. Вроде логично: собирал-то я в неоптимизированном варианте, через `sbt fastLinkJS`. Для оптимизированной сборки нужно выполнить `sbt fullLinkJS`. Результат оптимизации не очень впечатлил — 35 секунд, но зато размер сборки всего 253Кб.

Для сравнения — сборка и запуск с нуля  обычной версии (без JS) через `sbt clean` + `sbt run` выполнится за 26 секунд, из которых чуть меньше 3 секунд будет само выполнение. Если просто запускать jar, то общее время будет 4 секунды. Тоже многовато, но с учетом числа копирований ради иммутабельности — приемлемо. Может, когда будет настроение, попробую оптимизировать.

[В официальных доках](https://www.scala-js.org/doc/internals/performance.html) пишут, что производительность Scala JS проседает в 1-3 раза по сравнению с обычным кодом. Т.е. мои 11+ раз выглядят весьма тухло.

Я вдумчиво посмотрел в свой код аж пять минут и решил поменять `List` на `Vector`, потому что у меня есть операции добавления в конец списка, хотя выбор между двумя этими СД [довольно трудный](https://stackoverflow.com/questions/6928327/when-should-i-choose-vector-in-scala) (на всякий случай: скаловский `Vector` — это хитрый trie, а не динамический массив, как можно подумать по названию). В обычном коде стало только хуже — время возросло до 5 секунд, т.е. стало больше на треть. А вот на фронте снизилось до 6 секунд. Все равно долго, но гораздо лучше, чем 35. И, получается, медленнее обычного кода всего в полтора раза, что укладывается в диапазон 1-3 из официальных бенчмарков. Ускорение спишу на разницу работы с памятью в JVM и JS, подробности оставлю как упражнение читателю :)

Что в итоге получилось — можно посмотреть [на гитхабе](https://github.com/ov7a/orders-matching/tree/scala-js), рекомендую сразу на [первый дифф](https://github.com/ov7a/orders-matching/commit/c5ff6c4f8008b73f62f7c661846deae16f6b1485) смотреть.

P.S. по последним постам может показаться, что я мазохист и люблю копаться во фронте, но нет — просто так получилось, что хотелось попробовать, а все руки не доходили (яжбэкендер).

