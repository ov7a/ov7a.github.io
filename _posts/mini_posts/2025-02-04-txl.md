---
layout: post
title: Txl
tags: [legacy]
tg_id: 589
---
После эксперимента с [OpenRewrite](/2024/08/01/openrewrite.html) планировал посмотреть что-то более надежное, а именно [Txl](https://www.txl.ca/txl-abouttxl.html). В целом, я остался доволен экспериментом.

Чтобы получить общее впечатление, я не изобретал велосипед и тупо выполнял задания из [Txl Challenge](https://www.txl.ca/txl-challenge.html). Примечательно, что там предлагается общаться по почте с одним из "Оракулов", чтобы получить помощь (делать я этого, конечно, не стал). 

Язык не очень сложный — все основы можно почерпнуть [из презентации](https://www.txl.ca/docs/TXLintro.pdf). Однако документация в целом не супер — это набор PDF. Искру добавляет неироничное использование шрифта Comic Sans. 

Установка оказалась простой. Ошибки не очень дружелюбные, но при этом цикл обратной связи достаточно короткий.

Киллер-фича по сравнению с OpenRewrite, на мой взгляд, — это валидация выхода: вместо просто "текста" на выходе получается тоже АСД. Т.е. замена либо применится и это будет корректный код, либо будет пропущена. Увы, за это приходится расплачиваться тем, что надо иметь хорошую грамматику для целевого языка и задабривать компилятор: например, if -> if преобразовать просто, а if -> switch уже тяжело, потому что типы другие.

На 3 задании долго тупил как раз из-за непоняток, как правильно преобразовывать типы, и в итоге пришлось подсмотреть готовые решения на GitHub. Еще у меня почему-то не работал `[list X]`, да и в целом любые преобразования кроме 1 к 1 давались тяжело. При этом преобразования 1 к 1 выглядят чуть ли не как куски кода из оригинала ("возьми такое и замени на сякое").

У технологии, на мой взгляд, 2 основных минуса. Во-первых, откуда-то надо добыть грамматику. Для какой-нибудь Java это легко, для чего-то типа Kotlin — до свидания. Во-вторых, как я понял, нет никакого способа предоставить контекст. С какими-нибудь функциями расширения Kotlin — удачи понять, откуда метод и что там сейчас в качестве `this`. Т.е. совсем произвольный код не очень понятно как преобразовывать с учетом того, что могут быть подключены библиотеки.

При всем при этом группа ученых [смогла написать скрипт](https://www.researchgate.net/publication/221429379_An_Experiment_in_Automatic_Conversion_of_Legacy_Java_Programs_to_C) для перевода Java на C#. Правда только с версии 1.1 и это заняло 8 месяцев.

Еще отмечу, что первая версия Txl появилась аж в 1985 году. В целом, мне кажется, что фундамент вполне хороший и если бы инструмент немного набрал бы популярности в нужное время, то описанные проблемы могли бы быть решены.

