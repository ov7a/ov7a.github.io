---
layout: post
title: Устройство компилятора Kotlin
tags: [kotlin, compiler]
---
В версии 1.4 JetBrains немного поменяли архитектуру компилятора и про это есть довольно интересный [доклад](https://www.youtube.com/watch?v=GEqgkaiBPdA) ([слайды](https://assets.ctfassets.net/oxjq45e8ilak/5ow4NA3H3aEjIUS6RCPVf3/8cb96dcf7cebfc4ef047a4420e2f581a/Simon_Ogorodnik_Kotlin_Compiler_v_proshlom_1.4_i_ne_tolko_2020_11_27_05_18_03.pdf)). В старом компиляторе были немного срезаны углы для быстрой разработки, а в новом все по классике: фронтенд-часть с выходом промежуточного представления (по факту — AST с дополнительной информацией) и бэкенд (который отвечает за генерацию исполняемого кода).

Из интересного:
- У языка все еще нет спецификации, покрывающей все нюансы языка. Источник правды про его работу — исходный код. Сейчас есть только [черновик спецификации](https://kotlinlang.org/spec/pdf/kotlin-spec.pdf). Например, на момент доклада узнать, какие есть варианты [смарт-кастов](https://kotlinlang.org/docs/typecasts.html#smart-casts), можно было только из кода (хотя сейчас в спецификации довольно подробно описана куча вариантов, в том числе пример-загадка из доклада).
- Внутри компилятора есть типы-пересечения (например, общий родитель у `Int` и `Float` — `Comparable<*> & Number`), но они невыразимы (надеюсь, что это "пока").
- Все `if` конвертируются в `when`, но писать лучше все равно по-человечески, ручные микрооптимизации будут только мешать компилятору.
- В бэкенд-части компилятора есть оптимизации, но они в основном используются для того, чтобы упростить конструкции, чтобы потом JIT'у было их проще понять и оптимизировать. Однако для Native и JS есть еще свои оптимизации, их больше.

Про устройство компиляторов есть еще [доклад](https://www.youtube.com/watch?v=Txzonr6Xj14) от небезызвестного Брагилевского (но там про Haskell уже). Я слушал его вживую на конференции, и он был неплох.

