---
layout: post
title: Текущие проблемы с потоками и асинхронщиной
tags: [java, hardware, scala]
tg_id: 360
---
Неплохой [доклад](https://www.youtube.com/watch?v=PLApcas04V0) про текущее состояние асинхронного выполнения задач в JVM, хоть и очень тезисный.

Вначале немного повторения кэши L1-L3 и устройство процессора в целом, про потоки, очередь задач и их конкурентное выполнение, переключение контекста. Потом внезапно переключается на JVM — каждый поток это корень для сборщика мусора. Чем больше потоков, тем медленнее он работает. Какой-нибудь FixedThreadPool не решает проблемы, т.к. у него случайный порядок выполнения.

Далее — основы асинхронного выполнения и epoll. "Многие из вас плохо читают на C, поэтому я перевел этот кусок кода на Scala":) Как решить проблему, что потоки ничего не делают, пока ждут? Перекинуть все ожидание на 1 поток. Но даже это дороговато. Эту проблему решили в nodejs-ной библиотеке libuv, которая в одном потоке и полезную работу делает, и ждет IO.

В идеальном мире на каждом ядре работает только один поток, одна задача по максимуму выполняется на своем потоке, чтобы все было хорошо с кэшами. А еще это все спрятано от прикладного программиста. Системы эффектов близки к этому, они хорошо решают проблему управления задачами, но все разбивается о нижележащие библиотеки для работы с потоками.

